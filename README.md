# ZATCA e‑Invoice PHP Package

هذا الحزمة مكتوبة بلغة PHP وتهدف إلى تسهيل عملية **إعداد، توقيع وإرسال الفواتير الإلكترونية** وفقًا لمواصفات هيئة الزكاة والضريبة والجمارك (ZATCA) في المملكة العربية السعودية. يمكن استخدامها مع أي مشروع PHP، بما فى ذلك إطار عمل Laravel، وتوفر الأدوات اللازمة لتوليد الفاتورة بصيغة XML، حساب البصمة الرقمية (hash)، توقيعها باستخدام مفاتيح ECDSA، توليد رمز الإستجابة السريعة (QR) وترميزها، وأخيرًا إرسالها إلى بوابة **فاتورة** من خلال واجهات البرمجة الخاصة بمرحلة التصفية (Clearance) أو التبليغ (Reporting).

## المزايا الرئيسية

* **نموذج فاتورة مرن** – يتيح لك الكلاس `Invoice` إعداد بيانات البائع، العملة، نسبة الضريبة، العنوان وأي عدد من عناصر السطر. ويمكن تمديده لإضافة معلومات المشتري، بدلات/خصومات، تاريخ التوريد، طريقة الدفع، ملاحظات، وغير ذلك.

* **توليد UUID وربط الفواتير المتسلسلة** – كل فاتورة تحصل على معرف فريد (UUID) وتُمكِّنك من الربط بالفاتورة السابقة عبر `previousInvoiceHash` وإدراج قيمة عداد الفاتورة (ICV) تلقائياً.

* **التوقيع والحماية** – تستخدم الحزمة خوارزمية SHA‑256 لتوليد بصمة الفاتورة ثم تقوم بتوقيعها بمفتاح خاص من نوع ECDSA. كما يتم استخراج المفتاح العام لإدراجه اختياريًا في QR.

* **توليد رمز استجابة سريع (QR)** – تُنشأ الحمولة بتنسيق TLV وتتضمن سبعة حقول أساسية (اسم البائع، الرقم الضريبي، الطابع الزمني، إجمالي الفاتورة، إجمالي الضريبة، بصمة الفاتورة، التوقيع) وحقلًا ثامنًا اختياريًا للمفتاح العام، ثم تُرمز Base64.

* **تعدد الشركات والبيئات** – من خلال ملف الإعداد `config/zatca.php` تستطيع تعريف عدة شركات (أو مستأجرين) مع بياناتهم الخاصة (اسم، رقم ضريبي، رقم سجل تجاري، العملة، النسب الضريبية، أنواع الفواتير المسموح بها، مسارات المفاتيح، بيانات الاعتماد، ونقاط النهاية). يمكن اختيار شركة افتراضية واستخدام أخرى عند الحاجة.

* **دعم الفواتير الضريبية والمبسطة** – لكل شركة يمكن تحديد نوع الفاتورة الافتراضي (`simplified` أو `standard`) وقائمة الأنواع المسموح بإصدارها. يقوم العميل باختيار نقطة النهاية المناسبة (التصفية للضريبية أو التبليغ للمبسطة) تلقائيًا عند إرسال الفاتورة.

* **الالتزام بمرحلة التكامل (Phase 2)** – عند تحويل الفاتورة إلى XML تُضاف عناصر إلزامية مثل `ProfileID=reporting:1.0`، شفرة نوع الفاتورة (`InvoiceTypeCode` 388 أو 389)، مجموعات الضرائب (BG‑23)، مجموعات المبالغ القانونية (BG‑22)، عنوان البائع الكامل، قيمة عداد الفاتورة (ICV) وبصمة الفاتورة السابقة (PIH) مع الرموز المطلوبة. تستخدم جميع حقول المبالغ خاصية `currencyID` المطابقة للعملة.

* **تعامل مع أخطاء الهيئة** – يتضمن الكلاس `ZatcaErrorHandler` طريقة `handle()` التي تفحص أي استجابة من واجهة ZATCA، وتستدعي اختيارياً رد نداء (`callback`) ثم ترمي استثناءً (`ZatcaException`) يحوي الفئة والرمز والرسالة للخطأ. يمكنك تعيين رد نداء عبر `setErrorCallback()` أو `on_error` في التهيئة لتسجيل الأخطاء أو تعديلها قبل معالجتها.

* **قابلية الاستخدام مع Laravel أو PHP خام** – يتوفر Service Provider يقوم بدمج الحزمة في Laravel تلقائيًا، نشر ملف الإعداد وربط العميل في حاوية الـ IoC. في بيئة PHP عادية يمكن تحميل التكوين يدويًا واستدعاء الأصناف عبر الـ autoloader.

> **تنويه**: هذه الحزمة للأغراض التعليمية وتعرض الخطوات الأساسية المطلوبة للتكامل مع ZATCA. يجب مراجعة المواصفات الرسمية ودمجها فى المشروع الفعلي، مع التأكد من توفير الأمن المناسب وإدارة المفاتيح السرية.

## التركيب

يفضل تثبيت الحزمة عبر Composer. إذا كنت تستخدم هذه الحزمة داخل مشروعك مباشرة، يمكنك إضافتها كاعتماد محلي باستخدام المسار:

```json
{
    "repositories": [
        {
            "type": "path",
            "url": "path/to/zatca-einvoice"
        }
    ],
    "require": {
        "meita/zatca": "*"
    }
}
```

ثم تشغيل:

```bash
composer install
```

الحزمة تمت تهيئتها بحيث يتم تحميل الأصناف ضمن مساحة الاسم `Meita\\Zatca\\`.

## الاستخدام السريع

### 1. التجهيز

قبل أن تتمكن من إرسال الفواتير، يجب الحصول على **معرف ختم التشفير (CSID)** والسر (**secret**) من بوابة المطورين التابعة لـ ZATCA. هذه العملية تشمل:

1. إنشاء طلب توقيع شهادة (CSR) وتقديمه للحصول على **CSID**.
2. إتمام الاختبارات عبر بيئة **Integration Sandbox** باستخدام **Compliance CSID API**.
3. عند اجتياز الاختبارات، ستتلقى **binarySecurityToken** و **secret** تستخدمهما كبيانات مصادقة.

ضع ملف المفتاح الخاص (`private_key.pem`) والملف العام (`certificate.crt`) في مكان آمن بداخل مشروعك؛ حيث تستخدمهما الحزمة لتوقيع الفواتير.

### 2. تكوين العميل

```php
use Meita\Zatca\ZatcaClient;
use Meita\Zatca\Invoice;

$client = new ZatcaClient([
    // عنوان واجهة البرمجة؛ استخدم sandbox للتجارب أو production للإرسال الفعلي
    'base_url' => 'https://sandbox.zatca.gov.sa/e-invoicing/core/v2',
    // معرف الختم الصادر (CSID)
    'client_id' => 'YOUR_CSID_HERE',
    // السر المرتبط بالـ CSID
    'secret'    => 'YOUR_SECRET_HERE',
    // المسار إلى المفتاح الخاص لتوقيع الفاتورة
    'private_key_path' => __DIR__ . '/keys/private_key.pem',
    // المسار إلى الشهادة العامة (اختياري في هذه النسخة)
    'certificate_path' => __DIR__ . '/keys/certificate.crt',
]);
```

### 3. إنشاء الفاتورة

```php
// البيانات المطلوبة للفاتورة، ويمكنك تخصيصها حسب احتياجاتك
$data = [
    'uuid'          => Invoice::generateUuid(),
    'issue_date'    => date('c'), // ISO 8601 timestamp
    'seller_name'   => 'شركة المثال للتجارة',
    'seller_vat'    => '123456789012345',
    'invoice_total' => 115.00,
    'vat_total'     => 15.00,
    // في حال كانت هذه ليست أول فاتورة، أدخل Hash الفاتورة السابقة
    'previous_hash' => null,
    // عناصر أخرى يمكن إضافتها فى ملف XML
    'items' => [
        [
            'name' => 'منتج 1',
            'quantity' => 1,
            'price' => 100.00,
        ],
    ],
];

$invoice = new Invoice($data);

// يمكن تعديل العناصر بعد الإنشاء
$invoice->setPreviousInvoiceHash('previousHashValue');
```

### 4. إرسال الفاتورة القياسية

```php
// هذه الطريقة تقوم تلقائياً بإنشاء XML، احتساب hash وتوقيعه، بناء رمز QR، ثم إرسالها عبر واجهة التصفية
$response = $client->sendStandardInvoice($invoice);

if ($response['status'] === 'success') {
    // احفظ الفاتورة المختومة (response['invoice']) كما هو موضح فى مواصفات ZATCA
    file_put_contents('cleared_invoice.xml', base64_decode($response['invoice']));
} else {
    // عالج الأخطاء بناءً على رسالة الرفض أو التحذيرات
    var_dump($response['errors']);
}
```

### 5. إرسال الفاتورة المبسطة

```php
$response = $client->sendSimplifiedInvoice($invoice);
// فى هذا النموذج، يجب أن تحتوى الفاتورة على الختم والرمز قبل الإرسال
```

## هيكل الأصناف الأساسية

### 1. `Meita\Zatca\Invoice`

يمثل الفاتورة ويوفر طرقًا لتوليد **UUID** وتكوين بيانات الفاتورة وتحويلها إلى XML. يعتمد على `DOMDocument` لتوليد ملف UBL بسيط. يمكنك تعديل طريقة `toXml()` لتضمين حقول إضافية حسب القاموس الرسمي.

### 2. `Meita\Zatca\Utilities\Signer`

يحتوي على وظائف لحساب **hash** للفاتورة باستخدام خوارزمية SHA‑256 وفقًا لمعيار C14N11، وتوقيع الـ hash باستخدام المفتاح الخاص عبر `openssl_sign`. يستخدم خوارزمية ECDSA (اختيارية: يمكن استخدام RSA إذا كانت متطلباتك مختلفة).

### 3. `Meita\Zatca\Utilities\QrCodeGenerator`

يبني تمثيلًا نصيًا (Base64) لرمز الإستجابة السريعة وفقًا لمواصفات TLV. يتضمن حقول: اسم البائع، الرقم الضريبي، الطابع الزمني، إجمالى الفاتورة، إجمالى الضريبة، Hash الفاتورة، التوقيع الرقمي، والمفتاح العام. لا يتضمن إنشاء صورة QR؛ بل يُرجع سلسلة Base64 يمكن تحويلها لصورة عبر مكتبات خارجية (مثل `endroid/qr-code`).

### 4. `Meita\Zatca\ZatcaClient`

يُعد الواجهة الرئيسية للتعامل مع ZATCA. يوفر الطرق:

* **`sendStandardInvoice(Invoice $invoice): array`** – يرسل الفاتورة القياسية للتصفية ويُرجع مصفوفة تحوى الحالة (`success` أو `error`) والفاتورة المختمة أو الأخطاء.
* **`sendSimplifiedInvoice(Invoice $invoice): array`** – يرسل الفاتورة المبسطة للتبليغ. يجب أن يكون الـ invoice قد تم ختمه وتضمين QR.
* **`prepareSignedInvoice(Invoice $invoice): array`** – لإنشاء ملف XML، حساب الـhash، التوقيع، توليد QR وإرجاع جميع القيم الضرورية دون إرسالها؛ يمكن استخدامه فى سيناريوهات التبليغ.

### 5. `Meita\Zatca\Support\InvoiceValidator`

توفّر هذه الكلاس طبقة تحقق مبسّطة لفحص بيانات الفاتورة قبل تمريرها إلى الكلاس `Invoice`. يمكن استخدام `InvoiceValidator::validate($data, $type)` للتأكد من وجود الحقول الأساسية وعدم ترك قيم فارغة. تُرجع الدالة مصفوفة بالحقول المفقودة أو غير الصالحة، وتدعم تحديد نوع الفاتورة (مبسطة أو ضريبية) لتطبيق قواعد إضافية (مثل ضرورة وجود `buyer_name` و `buyer_vat` للفواتير الضريبية). كما يمكن تمرير قائمة مخصصة من الحقول المطلوبة لتلائم احتياجاتك الخاصة.

مثال استخدام:

```php
use Meita\Zatca\Support\InvoiceValidator;

$data = [
    'seller_name'   => 'ACME Inc.',
    'seller_vat'    => '123456789012345',
    'invoice_total' => 100.00,
    'vat_total'     => 15.00,
    'items'         => [['name' => 'Item', 'quantity' => 1, 'price' => 100.00]],
    'issue_date'    => date('c'),
];

// تحقق من البيانات لفاتورة مبسطة
$missing = InvoiceValidator::validate($data, 'simplified');
if (!empty($missing)) {
    // تعامل مع الحقول المفقودة (عرض رسالة للمستخدم، طلب استكمال بيانات، إلخ)
    throw new Exception('حقول مفقودة: ' . implode(', ', $missing));
}
// إذا كانت القائمة فارغة يمكن إنشاء الكائن Invoice بأمان
$invoice = new Meita\Zatca\Invoice($data);
```

### 6. `Meita\Zatca\Support\InvoiceAdapter`

تتعامل هذه الكلاس مع تحويل أو **تطبيع** بيانات الفاتورة القادمة من مصادر مختلفة إلى الصيغة القياسية المستخدمة في الحزمة. بعض الأنظمة قد ترسل حقولًا بأسماء مثل `sellerName` أو `total_amount` بدلاً من `seller_name` و `invoice_total`. يوفر `InvoiceAdapter::adapt($input, $mapping)` آلية لتمرير مصفوفة الإدخال وتحديد خريطة لتحويل المفاتيح البديلة إلى المفاتيح القياسية، مع استخدام خريطة افتراضية لعدد من الحقول الشائعة.

مثال استخدام:

```php
use Meita\Zatca\Support\InvoiceAdapter;
use Meita\Zatca\Support\InvoiceValidator;

$raw = [
    'sellerName'   => 'ACME Inc.',
    'vatNumber'    => '123456789012345',
    'total_amount' => 115.00,
    'vatTotal'     => 15.00,
    'items'        => [['name' => 'Item A', 'quantity' => 1, 'price' => 100.0]],
    'invoiceDate'  => '2025-12-13T08:00:00+03:00',
];

// تطبيع البيانات إلى الصيغة القياسية
$normalized = InvoiceAdapter::adapt($raw);

// تحقق من وجود الحقول المطلوبة بعد التطبيع
$missing = InvoiceValidator::validate($normalized);
if ($missing) {
    throw new Exception('هناك حقول ناقصة: ' . implode(', ', $missing));
}

$invoice = new Meita\Zatca\Invoice($normalized);
```

## تشغيل الاختبارات

يحتوي هذا المشروع على مجموعة من اختبارات **PHPUnit** للتأكد من صحة وحدات الكود الخاصة بالحزمة (توليد الـ UUID، بناء ملف XML، حساب الـ hash، التوقيع، إنشاء QR، والدمج فى العميل). لتشغيل الاختبارات:

1. تأكد من تثبيت اعتماديات التطوير (تشمل PHPUnit) باستخدام Composer:

   ```bash
   composer install --dev
   ```

2. ثم قم بتشغيل الأمر التالي من جذر المشروع:

   ```bash
   vendor/bin/phpunit
   ```

سترى ملخصًا بالاختبارات التى تم تنفيذها ونتائجها. يمكنك استخدام هذه الاختبارات كنقطة انطلاق لإضافة اختبارات أخرى حسب احتياجات مشروعك.

## ملاحظات أمنية

* يجب تخزين **المفتاح الخاص** والـ **secret** فى أماكن آمنة وبصورة مشفرة وعدم مشاركتهما.
* لا تحتفظ بالسر فى مستودع الكود؛ استخدم متغيرات بيئة أو خدمات إدارة الأسرار.
* تأكد من استخدام اتصال `HTTPS` عند إرسال الفواتير لحماية البيانات.

## ترخيص

تم نشر هذه الحزمة تحت رخصة **MIT**. يمكنك استخدامها وتعديلها بحرية وفق شروط الرخصة.

## المساهمة

مرحبًا بجميع المساهمات! إذا وجدت مشكلة أو ترغب فى إضافة ميزة جديدة، الرجاء فتح تذكرة أو إرسال طلب دمج (Pull Request).
